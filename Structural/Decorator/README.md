# Decorator - 裝飾者模式
## 目的
為了維持開放封閉原則(允許類別容易擴充，在不修改現有程式碼的情形就能搭配新的行為)，裝飾者模式動態地將責任加諸於物件上，提供比繼承更有彈性的選擇。

## 舉例
以手搖飲料為例子，珍珠奶茶顧名思義就是奶茶加上珍珠，但現在有越來越多普通茶(紅茶、綠茶、烏龍茶)會因為客戶需求而加上(珍珠、布丁...等等)。

## 思考方向？
1. 隨配料增加而增加類別...
![Image](https://i.imgur.com/KNiXSQl.png)
    - 配料越多則子類別越多，很難維護...
2. 加配料這件事往上提升到父類別(欲繼承類別)...
![Image](https://i.imgur.com/8LsOg5p.png)
    - 父類別若有新需求就會異動，破壞開放封閉原則...

## 類別圖
![Image](https://i.imgur.com/xFh6QBi.png)

## 值得注意什麼？
- 裝飾者**繼承**被裝飾者，為的是**擁有相同的型態，而不是相同的行為**。
- 透過將**裝飾者和被裝飾者合成而產生的合成物件，促成新增加的行為**。
### 缺點
- 容易造成設計中有大量小類別，數量太多容易造成使用上的困擾。

## 測試
```
$ npm run test Decorator
```

## 參考文章
 - [裝飾者模式 (Decorator Pattern)](http://corrupt003-design-pattern.blogspot.com/2016/03/decorator-pattern.html)